ENTS 640 Networks and Protocols I
Fall 2018
Project
Assigned: November 14; Due: December 5, 4:00pm
Overview
Write a distributed networking application in Java consisting of a client and a server. The client will
send a block of data to the server, the server will perform some computations and return the result to the
client. The application should use Java’s UDP sockets (classes DatagramPacket and DatagramSocket and
their methods) and provide the necessary reliable data transfer functionality on the top of UDP’s
unreliable communication services by implementing the data transfer protocol described below.
Packet Structure
The Java application should use the following packets for communication between the client and the
server. When transmitting multi-byte quantities (e.g. sequence numbers, acknowledgement numbers,
etc.), they should be transmitted in network byte order. That is, the most significant byte is transmitted
first, the second most significant byte is transmitted next, and so on. The least significant byte is
transmitted last.
Using the data packet (referred to as DATA packet), the client will send a number of two-dimensional
(2D) vectors to the server. The DATA packet should have the following structure:
The fields of the DATA packet are as follows:
• Packet type (1 byte): This field describes the type of the packet, and it should have a value of
00h (the byte values will be given in hexadecimal notation).
• Sequence number (2 bytes): The sequence number is a 16-bit unsigned integer, and it should
count packets (and NOT bytes). Its initial value should be 0, and it should be incremented by
one for each additional sent DATA packet.
• Number of data vectors: This is a 16-bit unsigned integer, and its value is the number of 2D
vectors carried by the DATA packet. The maximum value of this field is 50; that is, a DATA
packet can carry at most 50 2D data vectors.
• Data vectors: This field is the payload of the packet and carries the floating-point 2D data
vectors in a byte-encoded format. The process of encoding the floating-point data vectors into
a sequence of data bytes will be described later.
The data acknowledgment (DACK) packet will be sent by the server to the client to acknowledge
every DATA packet. Its structure is shown below.
1The DACK packet should have the following fields:
• Packet type (1 byte): This field describes the type of the packet, and it should have a value of
01h.
• Acknowledgment number: This 16-bit field should contain the sequence number of the last
correctly received DATA packet.
The request (REQ) packet will be sent by the client to the server once all data vectors have been sent,
and it will request the server to start the computation on the sent data vectors. The REQ packet has a very
simple structure:
The packet type field (1 byte) should have the value of 02h.
The request acknowledgement (RACK) packet will also consist of a single byte, and it will be sent by
the server to the client to signal the receipt of the REQ packet. The RACK packet is shown below:
The packet type field (1 byte) should have the value of 03h.
The cluster information (CLUS) packet will be sent by the server to the client and will contain the
result of the computation, which will be two 2D vectors representing the calculated cluster centroids. The
CLUS packet will have the following structure:
The CLUS packet should have the following fields:
• Packet type (1 byte): This field describes the type of the packet, and it should have a value of
04h.
• Data vectors (16 bytes): This field is carries 2 floating-point 2D data vectors in a byte-
encoded format. These two data vectors are the result of the server’s computation, and
contain the 2 cluster centroids. The process of encoding the floating-point data vectors into a
sequence of data bytes will be described later.
2The cluster information acknowledgment (CACK) packet will be sent by the client to the server,
acknowledging the receipt of the CLUS packet. The CACK packet will consist of a single byte:
The packet type field (1 byte) should have the value of 05h.
Data Vector Byte Encoding
The data vectors are 2D real vectors, and their coordinates (components) should be stored and
manipulated as floating-point values. However, in order to be able to transmit them over a byte-oriented
transport protocol, they will need to be converted into a byte sequence. This conversion should take place
as follows.
First, each floating-point value representing a dimension (coordinate) of the data vector should be
multiplied by 100 and then converted to a 32-bit integer value. Then, using bit shift and bit masking
operations, all 4 bytes of the 32-bit integer should be extracted and represented as individual byte values.
As the result, a single floating-point dimension will be represented as 4 bytes, and a 2D data vector will
be represented as 8 bytes.
Both dimensions (coordinates) should be converted to a byte sequence and transmitted. The 1 st
dimension (coordinate) should be transmitted first, and the 2 nd dimension (coordinate) should be
transmitted last. The 4 bytes of each dimension (coordinate) should be transmitted in network byte order.
The reverse (byte sequence to floating-point value) conversion should follow the same steps in
reverse order. A 32-bit integer value should be assembled from the contributing 4 byte values, the integer
should be converted to a floating-point value, and this value should be divided by 100.
Protocol Operation
First, you need to set up the client and server UDP socket parameters (IP addresses, port numbers
etc.) so that the two sides could communicate with each other. Then, the client should read in the floating-
point 2D data vectors from a data file (provided with the project description) and store them in an
appropriate data structure (array or ArrayList ). The data files contain one 2D data vector per line
enclosed in parentheses, and the dimensions (coordinates) of the vector are separated by commas. The
first value on each line is the 1 st dimension (coordinate), and the second value is the 2 nd dimension
(coordinate) of the 2D data vector.
Two data files will be provided ( data01.txt and data02.txt ), The file data01.txt contains 243 2D
vectors, while the data02.txt file contains 114 vectors. The application should be run with both data files
in two separate runs and the output should be recorded for both runs separately.
The system should work in three consecutive phases: the data vector upload phase, the computation
request phase and the result download phase. The client protocol should operate as follows:
A. Data vector upload phase
1. The client should create as many DATA packets as necessary to be able to send all data
vectors to the server, fill out the header fields of each DATA packet and insert the byte-
encoded data vectors in the payload. Then, it should send the DATA packets one by one
to the server.
32. The client should wait for a DACK packet from the server before sending the next DATA
packet. A DACK packet can only be accepted if: a) it has the correct packet type, and b)
the ACK number is equal to the sequence number of the previously sent DATA packet.
All other received packets should be discarded (ignored).
3. The client should also start a timer upon sending each DATA packet, and retransmit the
packet if the timer expires before receiving a DACK packet from the server. The initial
timeout value should be set to 1 second and should be doubled on each timeout event.
After the 4th timeout event, the transmitter should declare communication failure and
print an error message.
B. Computation request phase
1. The client should send a REQ packet to the server, signaling that all data vectors have
been sent and asking the server to start computing the result. Then, the client should wait
for a RACK packet from the server. A RACK packet can only be accepted if it has the
correct packet type field.
2. The client should also start a timer upon sending the REQ packet, and retransmit the
packet if the timer expires before receiving a RACK packet from the server. The initial
timeout value should be set to 1 second and should be doubled on each timeout event.
After the 4th timeout event, the transmitter should declare communication failure and
print an error message.
C. Result download phase
1. In this phase, the client will become the receiver and wait for a CLUS packet from the
server. If it does not receive the CLUS packet in 30 seconds, it should stop and declare
server failure.
2. When the client receives the CLUS packet, it should send back a CACK packet to the
server acknowledging the receipt of the CLUS packet. A CLUS packet can only be
accepted if it has the correct packet type.
3. Finally, the client should extract the two 2D data vectors from the CLUS packet, convert
them into floating-point vectors and display them on the screen. It should also wait for
any additional (duplicate) CLUS packets from the server, and send back a CACK packet
if needed.
The server should implement the following protocol.
A. Data vector upload phase
1. The server should wait for and receive the DATA packets, and send a DACK packet to
the client if the DATA packet is correctly received. The ACK number field in the DACK
packet should be set to the sequence number of the last correctly received DATA packet.
The DATA packet is correctly received only if it has the correct sequence number and the
correct packet type. If the packet type is correct, but the sequence number is not, it should
send back a DACK packet with the ACK number field set to the sequence number of the
last correctly received DATA packet, but the content of the out-of-order DATA packet
should be ignored. All other received packets should be discarded (ignored) without any
response. The server should know that the client’s initial sequence number is 0.
2. The server should also extract the byte-encoded data vectors from each correctly received
DATA packet, convert them to a floating-point format and store them in an appropriate
data structure. Note that at this point, the server does not know the total number of data
vectors it will receive, so storing the data vectors in an ArrayList seems more preferable.
3. The server should keep receiving DATA packets until it receives a REQ packet. The
REQ packet signals that all data vectors have been sent by the client.
4B. Computation request phase
1. Upon receiving the REQ packet, the server should send a RACK packet to the client.
Note that a RACK packet may get lost, so the server may receive it multiple times. The
server should start a timer set to 3 seconds, and if it does not receive any REQ packets
during this time, it can assume that the RACK packet has been received by the client.
2. The server then should start the computations. It should take all 2D data vectors received
from the client, and perform K-means clustering on them assuming two clusters. The
details of the clustering algorithm are provided below. The result of the computation will
be two data vectors, representing the centroids of the two clusters.
C. Result download phase
1. When the server is done with its computations, it should take the resulting two cluster
centroid vectors, convert them to byte-encoded format, create the CLUS packet and send
it to the client.
2. The server should wait for a CACK packet from the client and start a timer upon sending
the CLUS packet. It should retransmit the CLUS packet if the timer expires before
receiving a CACK packet from the client. The initial timeout value should be set to 1
second and should be doubled on each timeout event. After the 4th timeout event, the
server should declare communication failure and print an error message.
K-means Clustering
The server should perform K-means clustering on the received data vectors. K-means clustering is an
unsupervised machine learning algorithm, which takes a number of input vectors and separates them into
K clusters. In this case, there will be two clusters, so K = 2. Figure 1 shows an example of such data set.
Input data distribution
4
3
2
1
0
-1
-2
-3
-4
-4
-3
-2
-1
0
1
2
dimension 1
Figure 1: Example input data distribution
5
3
4After the algorithm has run, the data set will be partitioned into K non-overlapping (convex) clusters,
and the centroid (center point) of each cluster will be calculated. Theses centroids are used to represent
the clusters, and new data points can be assigned to the cluster whose centroid is closest to the new data
point. An example clustering result is depicted in Figure 2 for the data set of Figure 1 with two clusters.
The cluster assignment is shown by different colors, and the centroids are denoted by circles.
Final custer assingment and centroids
4
3
2
1
0
-1
-2
-3
-4
-4
-3
-2
-1
0
1
2
3
4
dimension 1
Figure 2: Final cluster assignment and centroids
We will use 2D data vectors, so each data vector =
1 , 2
= 1, 2, ...
two dimensions (coordinates): 1 and 2 . To evaluate how close two vectors and
other, the Euclidean distance will be used:
,
=
1 −
1
+
2 −
2
will have
are to each
.
The algorithm will go through the following steps:
1. Initialization: Randomly initialize the two cluster centroid vectors
=
1 ,
2
and
=
1 ,
2 . A practical way to do this is to calculate the range (the
maximum and minimum values) along each dimension of the data vectors and pick a random
number for each centroid within this range. Then, set the convergence constant to = 10 .
2. Do the following in a loop:
1. Start with two empty clusters, ! and ! .
2. Assign each data vector to the cluster whose centroid is closest to that data vector.
That is, for = 1, 2, ... , assign to ! if
,
<
,
; otherwise assign
to ! .
3. Recalculate the cluster centroid vectors as the averages of the data vectors that were
will be the average of all data vectors
assigned to that cluster. That is, the new
assigned to ! , and the new
will be the average of all data vectors assigned to ! .
Please note that these are 2D vector quantities, so the average (or arithmetic mean)
will also be a 2D vector.
Repeat until the cluster centroids stop changing. That is, by denoting the cluster centroids
calculated in the previous iteration by #$% and #$% , repeat the iterations until
#$%
#$%
,
+
,
< .
6The result will be the last cluster assignment and the last cluster centroid vectors,
two cluster centroid vectors should be returned by the server to the client.
and
. These
Hints
1. To open and read data from text files, check out the FileReader and the BufferedReader classes
and their methods. You can also use regular expressions to extract the data values efficiently (the
Pattern and Matcher classes in the java.util.regex package).
2. The integer data types in Java are all signed, so be careful with converting between those types
and performing arithmetic operations with those types.
Deliverables and Deadline
Each goup needs to submit the Java source code implementing the above described application.
Please only send me .java source files, and do not send me .class or any other compiled or executable
files. In addition, each group should write a project report (10-15 pages) discussing the problem, their
design and solution (flow charts, block diagrams, UML class diagrams, state transition diagrams, etc.),
and the application’s output, demonstrating the implemented functionality. The ourput should show some
cases where the protocol works without any errors, and also some cases where error occurs (e.g. timeout,
invalid packet type, etc.)
The perfect solution will receive 30 points (30% of the final grade). All materials shuld be submitted
electronically as email attachment (to zsafar@umd.edu), one per group, by December 5, 4:00pm in a
single email. You are encouraged to send me a single zipped file containing both the Java source code
files and the project report.
Late submissions will receive reduced points as follows:
• One day late (before December 6, 4:00pm): 50% reduction – maximum 15 points
• Two days late (before December 7, 4:00pm): 20% reduction – maximum 6 points
• More than two days late: 0 points
Please note that in addition to correctness and functionality, the Java code will also be evaluated for
coding style. Thus, you should pay attention to software design/engineering issues: code modularization,
class design, code block organization, variable naming, comments, etc.
The last note is on academic integrity: Each group is welcome to discuss the project in general terms
with other groups or students. However, when it comes to a particular solution to a particular problem
arising during the project work, it must be a result of only the work of the group members. Copying
code from other groups or any other source or sharing code with other groups are strictly
forbidden and will not be tolerated.
7￼ Commit new file
